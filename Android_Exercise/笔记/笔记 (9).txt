1.app/src/main/res/layout/activity_my.xml 是新建Activity所对应的xml布局文件
	当前Activity显示的文字内容，文本框等都在此设置。
2.app/src/main/java/com.mycompany.myfirstapp/MyActivity.java
是针对刚刚所创建的Activity类的各种定义，通过这个文件调用相应的xml布局文件，实现各种布局。
3.app/src/main/AndroidManifest.xml
真的整个项目（创建的APP）的基本特征的描述，例如APP名称，组成应用的各种组件等。
4.app/build.gradle 是Android Studio编译环境的说明。其中具有以下几个关键字：
	apply plugin://声明是Android程序
	compileSdkVersion 23//编译SDK版本
	buildToolsVersion "23.0.3"BuildTools版本
	applicationId "com.example.administrator.myapplication"//创建项目时应用的包名
	minSdkVersion 15//新建应用指定的最低支持的SDK版本
	targetSdkVersion 23 //新建应用指定的最高支持的SDK版本
	dependencies{}//编译目录下的jar包

5.不同于Eclipse Android Studio将resources资源文件夹直接拆分，功能分别为：
	drawable<density>/存放各种densities图像的文件夹，mdpi，hdpi等，这里能够找到应用运行时的图标文件ic_launcher.png
	layout/存放用户界面文件，如前边提到的activity_my.xml，描述了MyActivity对应的用户界面。
	menu/存放应用里定义菜单项的文件。
	values/存放其他xml资源文件，如string，color定义。string.xml定义了运行应用时显示的文本"Hello world!"

6.LinearLayout流水型布局，通过android:orientatiion属性来设置布局样式（水平或是垂直）

7.一些常见的属性：
	android:id：定义view的唯一标识符，例如：android:id="@+id/唯一ID值"（"+"号只是在第一次创建id号时才使用，已经创建的直接通过"@"符引用，设置id时，不同类型资源设置相同id可以被接受）
	android:layout_width 和android:layout_height:设置控件的宽和高，通常不指定具体值，只是使用wrap_content（占据内容大小空间）、match_parent（布满整个屏幕以适应父布局的大小）例如：android:layout_width:wrap_content
	android:hint:设置文本框为空的时候，默认显示的字符串。

8.res/values是资源文件夹，里面包含一些对资源文件的说明。例如string.xml就是字符串资源，当我们在用户界面定义一个文本的时候，应把每一个文本字符串列入资源文件，便于修改时在资源源文件中进行即可。把文本写在资源文件里，定义一个name属性（例子定义为：textView)在布局文件中再进行引用，例如：android:hint = "@string/textView"

9.android:layout_weight：设置控件的权重。（如果只设置了一个View的权重大于0，则该View将占据除去别的View本身占据的空间的所有剩余空间。使用权重的前提一般是给View的宽或者高的大小设置为0dp）

10.Activity之间通过Intent传递数据。

11.Action Bar 顶部的小工具栏，可以用来显示图标，标题，设置菜单栏，搜索等。定义在res/menu资源中。(通过在项目的 res/menu 目录中新增一个 XML 文件来为 action bar 添加操作)

12.不同密度下的图像：
	xhdpi: 2.0
	hdpi: 1.5
	mdpi: 1.0 (基准)
	ldpi: 0.75
	这意味着，如果针对xhdpi的设备生成了一张200x200的图像，那么应该为hdpi生成150x150,为mdpi生成100x100, 和为ldpi生成75x75的图片资源。
	mdpi/hdpi/xhdpi/xxhdpi 比例 1:1.5:2:3

13.可以在AndroidManifest.xml中定义作为主activity的activity

14.隐式Intent通过对app/src/main/AndroidManifest.xml配置相应的<activity>标签下的<intent-filter>使用
	包括两个属性：<action>和<category>使用时直接在Intent的构造函数中传递<action android:name>值

15.使得LinerLayout 可以滚动，套上一个<ScrollView>:
	<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scrollbars="vertical"
    android:fadingEdge="vertical"
    >
		<LinerLayout>....(若LinerLayout使用了权重，则不能添加滚动）
		</LinerLayout>
	</ScrollView>

16.设置一个3秒跳转的欢迎页：（加在onCreate的setContentView后）
	new Handler().postDelayed(r,3000); //欢迎页自动跳转
    }
    Runnable r = new Runnable() {
        @Override
        public void run() {
            Intent intent = new Intent(MainActivity.this,News_List.class);
            startActivity(intent);
            finish();
        }
    };

17.获取ActionBar 对象：（在相应Activity 的.java中写）
	ActionBar actionBar = getSupportActionBar();
	---------------------------------------------
	显示ActionBar 的返回键：
	actionBar.setDisplayHomeEnable(true);
	actionBar.setDisplayHomeAsUpEnable(true);

18.ActoonBar 最右边的三个点就是overflow按钮

17.常用的XML转义字符记录如下：(编辑<string>文件会用到）
 
         空格： <string name="out_bound_submit">出&#160;&#160;库</string> 其中的&#160;就代表空格
 
       换行： <string name="hello_world">你好！\n世界！</string> 其中的\n就代表换行
 
       缩进： <string name="hello_world">你好！\t世界！</string> 其中的\t就代表按一次Tab键的几个空格
            应当注意，由于系统定义的基本的缩进的格数不同，有的代表4个半角字符，有的代表8个半角字符，          
       所以可能显示时效果不同，建议如果编写界面时尽量少用。
 
 
        "  ： &#34; 或 &quot; 
         '   ： &#39; 或 &apos;
        &  ：  &#38; 或 &amp;
        lt(<)   ： &#60; 或 &lt;
        gt(>)  ： &#62; 或 &gt;

19.对TextView进行居中操作：
	 有2种方法可以设置TextView文字居中：
		一：在xml文件设置：android:gravity="center"
		二：在程序中设置：m_TxtTitle.setGravity(Gravity.CENTER);
			（备注：android:gravity和android:layout_gravity的区别在于前者对控件内部操作，后者是对整个控件操作。）
			例如：android:gravity="center"是对textView中文字居中android:layout_gravity="center"是对textview控件在整个布局中居中
其实很容易理解，出现"layout"就是控件对整个布局的操作

20.Textview 设置加粗通过 android:gravity属性进行设置

21.监听ActionBar左上角箭头后退：(重写onOptionsItemSelected方法)：
	 @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if(item.getItemId() == android.R.id.home) {//android.R.id.home（指箭头）
            onBackPressed();
            return (true);
        }
        return super.onOptionsItemSelected(item);
    }

22.改变Textview点击时文字的颜色：
	在drawable中添加一个新的xml(要是selector文件）：
	<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true" android:color = "#66CCFF"/>
    <item android:state_pressed="true" android:color = "#66CCFF"/><!--点击文本时变化的颜色-->
    <item android:state_selected="true" android:color ="#66CCFF"/>
    <item android:color = "#808080"/><!--文本未被点击时显示的颜色-->
</selector>

23.使用隐式intent进行Activit跳转时，要在AndroidManifest.xml 中要跳转到的Activity中添加<action>和<category>：
	<action>和<category>用作筛选条件，<action>为必须项，其android:name 属性定义为 "完整包名.自己定义部分"
					  <category>可选，但即使不定义也要将android:name名定义为："android.intent.category.DEFAULT"
	之后在出发跳转的页面的onCreate方法中添加 intent 对象，并使用intent.setAction(刚刚定义的andorid:name)和intent.setCategory(相应的android:name）获取事件
	最后使用startActivity(intent)进行跳转。
	例如，我要从MainActivity跳转到second_Activity，包名为：com.example.administrator.myapplication
	
	AndroidManifest.xml:
		<activity
            		android:name=".second_Activity"
            		android:label="@string/title_activity_second_"
            		android:theme="@style/AppTheme.NoActionBar"
            	>
           	 <intent-filter>	//自行添加到intent-filter>
               	 	<action android:name = "com.example.administrator.myapplication.second_Activity" /> //要写完整包名
                	<category android:name = "android.intent.category.DEFAULT"/>
            	</intent-filter>
        	</activity>
	
	MainActivity.java：
			//在onCreate()方法相应的监听事件被出发时函数中：
			Intent intent = new Intent();
                	intent.setAction("com.example.administrator.myapplication.second_Activity");
                	intent.addCategory( "android.intent.category.DEFAULT");
                	startActivity(intent);

24.调用浏览器打开相应的网站：
	在相应的onClick方法中使用系统默认intent对象：
		Intent intent = new Intent(Intent.ACTION_VIEW);
                intent.setData(Uri.parse("http://www.baidu.com"));//parse()将网址转成字符串，setData()将数据传递出去
                startActivity(intent);

25.可在AndroidMainfest.xml中的<intent-filter>标签设置<data>标签，用来规定当前Acttivity能够相应的数据类型

26.Activityt跳转时数据传递：
	Intent对象使用	putExtra(键值，实际数据)	方法来把当前Activity数据暂存在Intent中，当Activity跳转后，在新的Activity可以同过	getIntent（）	方法获取之前的Intent对象，在通过获取的Intent对象调用	getStringExtra(键值)	方法获取保存在Intent中的数据，实现Activity之间的数据传递。

27.Activity 返回时的参数传递，用例子来说：（在相应的A1.java和A2.java操作）
	假设我们现在从A1跳转到A2后，从A2回来，要获取A2的数据
		我们要先在A1跳转至A2事件中调用	startActivityForResult(Intent对象，请求码）	方法指明要获取返回对象；
		之后在A2回跳到A1的事件finish（）调用之前调用	setResult(RESULT_OK或者RESULT_CANCELED,Intent对象) 	，注意A2的Intent对象要先putExtra()存放数据；
		最后重写A1中的		onActivityResult（请求码参数，RESULT_OK或者RESULT_CANCELED,Intent对象）	方法
			重写内容一般是 switch(请求码参数)
						case 请求码 ：if(RESULT_OK或者RESULT_CANNELED) {获取Extra}

28.为Activity定义一个事件:（在相应的.java文件中的onCreate()方法中进行操作）
	1.设置View相应的对象，例如	Button button = (Button)findViewById();
	2.通过View对象设置相应的监听器，例如	button.setOnClickListener(new OnClickListener)...
	
29.在AndroidMainfest.xml中，相应的<activity android:theme>属性可以设置主题，例如 <activity android:theme = "@style/Theme.AppCompat.NoActionBar">

30.临时数据的保存与取出：
	1.保存：
		通过重写onSaveInstanceState(Bundle outState)方法实现
			例如：
				protected void onSaveInstanceState(Bundle outState) {
					super.onSaveInstanceState(outState);
					String tempData = "Something you just type";
					outState.putString("data_key",tempData);//putString(键值，内容)
				}
	2.取出：(因为是onDestory()之后数据消失，再次启动在onCreate()要读数据，所以在onCreate()中取出）
		直接使用saveInstanceState中的相应数据类型的方法进行取出
			例如：
				if(saveInstanceState != null) {
					String tempData = saveInstanceState.getString("data_key");
				}

31.查询当前在运行的Activity:
	通过新建一个BaseActivity并让其他所有类继承它，在BaseActivity的onCreate()中调用Log.d("BaseActicity",getClass().getSimpleName()) 在Log中显示当前活动的Activity名称。

32.
android.util.AndroidRuntimeException: requestFeature() must be called before adding content 
错误解决办法：
	requestWindowFeature(Window.FEATURE_NO_TITLE);
	setContentView(R.layout.);
按顺序放。在可行的条件下，去掉requestWindowFeature(Window.FEATURE_NO_TITLE)

33.简化代码的activityStart()的写法：
	public static void actionStart(Context context, String data1, String data2) {
		Intent intent = new Intent(context, SecondActivity.class);//设置要跳转的是SecondActivity
		intent.putExtra("param1", data1);
		intent.putExtra("param2", data2);
		context.startActivity(intent);
	}

 
   actionStart()的使用：（在执行跳转的页面中加）
		SecondActivity.actionStart(FirstActivity.this, "data1", "data2");

34. <EditText>控件中使用:
		android:hint 显示未输入时的文字
		android:maxLines 指定可输入的最大行数
		

35.使用Toast 在MainActivity显示一个消息框：
	Toast.makeText(MainActivity.this,inputText,Toast.LENGTH_LONG).show();
	      参数说明：(显示的Activity,显示内容，时长Toast.LENGTH_LONG|Toast.LENGTH_SHORT）

36.动态改变<ImageView>使用的方法：（在相应的.java文件中相应的事件触发时添加）
	imageView.setImageResource(R.drawable.jelly_bean);//imageView 是 ImageView 得到id后的对象

37.监听事件的两种写法：
	第一种：(使用匿名类）
		Button botton = (Button) findViewById(R.id.button);
		botton.OnClickListener(new View.OnClickListener() {//到这步基本自动生成
            		@Override
            		public void onClick(View v) {
			......
			}
		}
	----------------------------------------------------------------------------------------
	第二种：（实现接口）
		public class MainActivity extends Activity impletements OnClickListener {
			private Button button ;
			protected void onCreate (Bundle saveInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.activity_main);
				button = (Button)finViewById(R.id.button);
				button.setOnClickListener(this);
			}
			@OverWrite
			public void onClick(View v) {
				switch (v.getId()) {
					case R.id.button :
						......
						break;
					defult:
						break;
				}
			}	
		}
		

38.布局可以嵌套

39.设置LinearLayout控件的android:padding属性 可控制LinearLayout内部控件距离其他控件之间的距离

40.android：textstyle:可以设置文字效果（加粗、倾斜等）

41.
Android RelativeLayout 属性
// 相对于给定ID控件
android:layout_above 将该控件的底部置于给定ID的控件之上;
android:layout_below 将该控件的底部置于给定ID的控件之下;
android:layout_toLeftOf    将该控件的右边缘与给定ID的控件左边缘对齐;
android:layout_toRightOf  将该控件的左边缘与给定ID的控件右边缘对齐;
android:layout_alignBaseline  将该控件的baseline与给定ID的baseline对齐;
android:layout_alignTop        将该控件的顶部边缘与给定ID的顶部边缘对齐;
android:layout_alignBottom   将该控件的底部边缘与给定ID的底部边缘对齐;
android:layout_alignLeft        将该控件的左边缘与给定ID的左边缘对齐;
android:layout_alignRight      将该控件的右边缘与给定ID的右边缘对齐;
// 相对于父组件
android:layout_alignParentTop      如果为true,将该控件的顶部与其父控件的顶部对齐;
android:layout_alignParentBottom 如果为true,将该控件的底部与其父控件的底部对齐;
android:layout_alignParentLeft      如果为true,将该控件的左部与其父控件的左部对齐;
android:layout_alignParentRight    如果为true,将该控件的右部与其父控件的右部对齐;
// 居中
android:layout_centerHorizontal 如果为true,将该控件的置于水平居中;
android:layout_centerVertical     如果为true,将该控件的置于垂直居中;
android:layout_centerInParent   如果为true,将该控件的置于父控件的中央;
// 指定移动像素
android:layout_marginTop      上偏移的值;
android:layout_marginBottom 下偏移的值;
android:layout_marginLeft 　　左偏移的值;
android:layout_marginRight 　 右偏移的值;
--------------------------------------------------------------------------------------------------------------
example:
android:layout_below = "@id/***"
android:layout_alignBaseline = "@id/***"
android:layout_alignParentTop = true
android:layout_marginLeft = “10px”
---------------------------------------------------------------------------------------------------------------

42.AlerDialog用法：弹出提示框（写在相应的.java事件中）
	AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);//构造
                dialog.setTitle("Waring!");//设置标题内容
                dialog.setMessage("Test for AlerDialog.");
                dialog.setCancelable(false);//是否可以取消
                //↓设置选择按钮并监听
                dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() { //确认事件是PositiveButton
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {

                    }
                });
                dialog.setNegativeButton("Cannel", new DialogInterface.OnClickListener() { //取消事件是NegetiveButton
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {

                    }
                });
                dialog.show();//显示

43.ProgressDialog用法，带进度条的弹出提示框：
	ProgressDialog.Builder dialog = new ProgreeDialog.Builder(MainActivity.this); //构造
		dialog.setTitle("PrigressDialog"); //设置标题
		dialog.setMessage("New Loding....");//设置内容
		dialog.setCancelable(true); //返回键是否可以取消窗体
		dialog.show()//显示窗体，用dismiss（）方法用来使窗体消失

44.<TableLayout>几个属性：
	<TableRow>增加行，在行中加控件自动为一列
	<TableLayout android:strechClumns = 0> //第0列的内容适应屏幕（0 1 2列，从0开始）
	<TableRow android:layout_span = 2> //合并2列	

45.在一个layout中引用别的layout文件：(相当于添加其他控件）
	<include layout = @latouy/...>

46.<ListView>基本使用方法：
	(1).在layout.xml中添加<ListView></ListView>
	(2).在显示的Activity的.java中的OnCreate()写：
		ArrayAdapter<String> adaper = new ArrayAdapter<String>(MainActive.this,R.layout.item1,data); 
			//构建Adaper，<String>使用泛型，根据数据源类型改变，三个参数分别指（显示的Activity,为item设置的布局样式，数据源）
		ListView listview = (ListView) findViewById (R.id.listview); //获取ListView对象
		listview.setAdapter(adapter);//为ListView设置Adapter

47.动态加载布局文件：
	使用LayoutInflater.from(context).inflate(加载布局的id，父布局)

48.自定义Adapter写法范例（继承自ArrayAdepter,用的是自定义泛型Location）：P135
	新建class：
	public class LocationAdapter extends ArrayAdapter<Location> {
    private int resourceId;
    public LocationAdapter (Context context, int textViewResourceId, //重写父类构造方法
                            List<Location> objects){
        super(context,textViewResourceId,objects);
        resourceId = textViewResourceId;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) { //重写getView()方法
        Location location = getItem(position);					//获取当前的item实例
        View view;
	ViewHolder viewHolder;							//使用内部类ViewHolder获取布局对象并缓存，优化代码，避免每次重复获取
		if(converView == null) {
			view =  LayoutInflater.from(getContext()).inflate(resourceId,null);	//获取自定义的item.xml布局
			viewHolder = new ViewHolder;						//没有缓存时，实例一个ViewHolder对象获取控件
			viewHolder.textView = (TextView) view.findViewById(R.id.text_name);
			viewHolder.image = (ImageView) view.findViewById(R.id.image_id);
			view.setTag(viewHolder);						//将缓存放在view中
		}else { 
			view = convertView; //converView用于缓存加载过的布局，这样判断避免每次重复加载
			viewHolder = (ViewHolder) view.getTag();//从新获取缓存的ViewHolder
		}
        viewHolder.textView.setText(location.getName());					//通过viewHolder对象对自定义布局的对象进行操作
        viewHolder.imageView.setImageResource(location.getImageId());
        return view;
    }
    
   class ViewHolder {				//定义内部类ViewHolder
	TextView textView;
	ImageView imageView;
   }
}
-------------------------------------------------------------------------------------------------------------------
自定义Adapter使用方法：
	在OnCreate()构建Adapter时使用自定的Adapter:
		LocationAdapter locationadapter = new LocationAdapter<Location>(MainActivity.this,R.layout_item,list);
			//通常数据源定义为List并通过函数初始化


49.监听ListView的点击事件：
	在触发事件的方法中ListView对象实现setOnItemListener()设置监听器
	例如： listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
			......事件
            }
        });

50.获取ListView中的item的数据：
	1.重写getItem（）方法：
		public Object getItem(int position) {
        		return mlist.get(position).get("title");
    		}
	2.获取position：（在OnItemClick()方法中）
		ListView listview = (ListView)parent;
                String str = (String)listview.getItemAtPosition(position);

51.ListView子View 的点击：
	在自定义Adapter.java中写，由于缓存的ViewHolder已经得到了相应View的对象，直接使用viewHolder为相应的view设置OnClickLinstener监听器即可;
	响应的子View xml要设置为：android:focusable="false"

52.ListView点击按钮加载更多item：
	1.在一个新的xml(load_more.xml)中写一个Buttom;
	2.在已有的ListView(MainActivity.java)中装载该Button：
		创建一个Holder holder = new holder()类对象，用于创建线程;
		LoadMoreView = getLayoutInflater().inflate(R.layout.load_more,null);
        	Load_More_Button = (Button) LoadMoreView.findViewById(R.id.load_button);
		
		mlistView.addFooterView(LoadMoreView);
	3.响应点击事件通过holder新建线程，从而添加数据:
		handler.postDelayed(new Runnable() {
            @Override
            public void run() {
			.....(相应事件）
                mlistView.setSelection(visibleLastIndex - visibleItemCount + 1);
                Load_More_Button.setText("Load More");
            }
        },2000);
	4.通知Adapter更新数据：
		mAdepter.notifyDataSetChanged();

53.OnScroll监听器写法：（在监听的Activity中写）
	1.定义全局变量用来监听最后一项的索引和当前页面的可视项
		private int visibleLastIndex = 0;//最后一项可视项的索引
    		private View LoadMoreView;	//当前窗口可见项的总数
	2.重写OnScroll()//只有有滑动，就调用此方法
	      OnScrollChanged()//滑动状态发生改变时（从动到不动，从不动到动）调用此方法
		方法，所在的Actticity要implement OnScrollListener接口，直接重写此方法

			@Override
 		   	public void onScrollStateChanged(AbsListView view, int scrollState) {
            			int visiblelastitem = mAdapter.getCount() - 1; //获取最后一项数据索引
           			int lastindex = visiblelastitem + 1 ; //前面最后加了一个Button所以要加1
            			if (visibleLastIndex == lastindex && scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE) { //SCROLL_STATE_TDLE表示滑动停止了
                					....（事件响应）
            			}
    			}

    			@Override
    			public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
        			this.visibleItemCount = visibleItemCount;// 得到当前页面显示的item数目
        			visibleLastIndex = firstVisibleItem + visibleItemCount - 1;//得到最底部的索引项，但索引从0开始故减1
    			}

54.ListView的item数据的更新：（例子用点击事件发生时改变Context值）
	方法（1）：直接改变相应的TextView，在OnCilck()方法触发事件中写：
			int visibleFirstItem = mlistView.getFirstVisiblePosition();//获取当前屏幕第一个item的Position值
			View v = mlistView.getChildAt(position - visibleFirstItem);//相减得到点击的item在当前屏幕显示的实际位置，之后根据此位置定义子View对象对其进行修改实现数据更新
			TextView tv = (TextView) v.findViewById(R.id.context);
			tv.setText("Change");
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	方法（2）：建立新的的数据对象，通过数据对象改变已有的数据，之后使用Adater的notifyDataSetDataChange()更新ListView
			Map<String,String> d = new HashMap();//建立新的数据对象
			d.put("context","Change");//在新建的数据对象中添加数据
			mlist.set(position,d);//用新的数据对象更新已有的数据
			mAdapter.notifyDataChange();//通知Adapter数据更新，重新加载ListView

55.TabHost的使用：（注意，TabHost、TabWight、FrameLayout 的id分别固定为：tabhost、tabs、tabcontext)
	方法（1）:MainActivity继承TabActivity在OnCreate()中使用TabHost对象创建tab：
		activity_main.xml中写：
				<FrameLayout
					android:id = "@android:id/tabcontent"
					...
				>
					<Tabhost
						android:id = "@android:id/tabhost"
						...
					>
						<LinearLayout  //定义第一个tab1下的布局样式	
							android:id = "@ + id/tab01"
							....	
						>
							<TextView>等各种其他view进行布局
						</LinearLayout>
			――――――――――――――――――――――――――――――――――――――――------------------------------------------------------------------------------------------------------------
						<LinearLayout	//定义第二个tab2下的布局样式
							android:id = "@ + id/tab02"
							.....
						>
							<TextView>等级其他各种view布局
						</LinearLayout>
			----------------------------------------------------------------------------------------------------------------------------------------------------
							<LinearLayout	//定义第二个tab3下的布局样式
							android:id = "@ + id/tab03"
							.....
						>
							<TextView>等级其他各种view布局
						</LinearLayout>
			----------------------------------------------------------------------------------------------------------------------------------------------------
					</TabHost>
				</FramLayout>
		
		MainActivity中写：OnCreate()方法中注掉原来的setContentView(R.layout.main_activity)否则后面重复绑定xml会报错
				在OnCreate()中：
					TabHost tabHost = getTabHost();//创建TabHost对象，对标签进行管理
					LayoutInflater.from(this).inflate(R.layout.activity_main,tabHost.getContentView(),true);//载入标签页布局
					//新建并添加标签页
					TabHost.TabSpec t1 = tabHost.newTabSpec ("t1");//新建一个标签页
					t1.setIndicator("标题");
					t1.setContext(R.id.tab01);//设置标签页内容，直接引用xml中的子Layout
					tabHost.add(t1);//添加新建的标签页,注意参数不要和子Layout搞混
							....第二个第三个标签页同上			
					//为标签添加监听器，此处用OnTabChangeLinstener()为例
					tabHost.setOnTabChangeLinstener(new OnTabChangeListener() {
						@Override
            					public void onTabChanged(String s) {
                				if(s.equals("tab1")) {
                    					Toast.makeText(MainActivity.this,"标签页1被点击",Toast.LENGTH_SHORT).show();
                				}
					});

	

	方法（2）：不继承TabActivity,直接在XML中哦使用<TabHost>控件，再在MainActivity.java中获取TabHost的id创建对象
		在main_layout.xml中写：
apply plugin: 'com.android.application'

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.3"

    defaultConfig {
        applicationId "com.example.shao.broadcasttest"
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:23.3.0'
    compile 'com.android.support:design:23.3.0'
}
			<TabHost
				android:id = "@+id/tabhost"
				...
			>
				<LinerLayout>//定义标签的布局
					<TabWight	//定义标签栏，放在后面则可置底
						android:id = "@android:id/tabs"
						...
					></TabWight>	
					<Framelayout	//定义内容栏
						android:id = "@android:id/tabcontext"
						...
					>
							<LinearLayout  //定义第一个tab1下的布局样式	
							android:id = "@ + id/tab01"
							....	
						>
							<TextView>等各种其他view进行布局
						</LinearLayout>
			――――――――――――――――――――――――――――――――――――――――------------------------------------------------------------------------------------------------------------
						<LinearLayout	//定义第二个tab2下的布局样式
							android:id = "@ + id/tab02"
							.....
						>
							<TextView>等级其他各种view布局
						</LinearLayout>
			----------------------------------------------------------------------------------------------------------------------------------------------------
							<LinearLayout	//定义第二个tab3下的布局样式
							android:id = "@ + id/tab03"
							.....
						>
							<TextView>等级其他各种view布局
						</LinearLayout>
			----------------------------------------------------------------------------------------------------------------------------------------------------
					</Framelayout>
				</LinerLayout>
			</TabHost>			
		在MainActivity中写：（不用动态引入主布局，保留setContenView(R.Layout.main_layout)方法
			在OnCreate()中写：
				TabHost tabhost = (TabHost) findViewById (R.id.tabhost);//获取TabHost对象
				tabhost.setup();//获取对象之后先setup才能从xml读取id
				tabhost.addTab(tabhost.NewSpec("t1").setIndicator("标题").setContext(R.id.tab001));//添加新标签
				...之后同方法一
	
	PS：也可以将各个tab的布局分别创建为tab.xml之后再分别动态加载（见47点，Tab写在主中，所以setContentView(R.layout.main_layout)要留


56.TabWight 添加图片的方法：（在外部写一个View composeLayout()方法设置布局样式，之后再添加tab时候传入 文字和图像 的参数）
	private View composeLayout(String s,int i) { //String是标题，i是加载图片的id
        	LinearLayout layout = new LinearLayout(this);//定义LinearLayout对象
        	layout.setOrientation(LinearLayout.VERTICAL);//设置layout布局属性
        	layout.setGravity(Gravity.CENTER);
        //向定义的layout中添加子view
        	ImageView iv = new ImageView(this); //创建ImageView对象
        	iv.setImageResource(i);             //设置图像
        	layout.addView(iv,new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));     //添加到layout中,之后的Params为对齐父布局

        	TextView tv = new TextView(this);   //创建TextView对象，用作Tab标题
        	tv.setText(s);                      //设置文本内容
        	tv.setGravity(Gravity.CENTER_HORIZONTAL);
        	layout.addView(tv,new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT));

        	return  layout;
    	}
-----------------------------------------------------------------------------------------------------------------------------------------------------
	在添加tab时调用该函数即可：
		tabHold.add(tabHold.Spec("t1").setContent(R.id.tab01).setIndicator( composeLayout("标题",R.drable.xxx)));

57.设置点击tab子项变化颜色：
	通过两个函数实现，首先在点击事件之前，tab添加以后初始化颜色；之后再点击事件触发后 更新颜色；
	(1)初始化颜色：
		tabHold.setCurrentTab(0);//程序打开时默认选择的tab，此处设为第1项
		inicolor(TabHold tabhold);//调用初始化颜色函数
		private void inicolor(TabHold tabhold) {
			for( int i = 0 ; i < tabHold.getTabWight().getChildCount ; i ++ ) {	//遍历tab并改变颜色
				tabHold.getTabWight().getChilAt(i).setBackgroundColor(Color.WHITE);
			}
			tabHold.getTabWight().getChildAt(0).setBackgroundColor(Color.Gray);//设置默认选择的tab为选中颜色
		}
	(2)改变颜色，点击事件触发时先调用：
		private void changecolor (TableHold tabhold) {
			for( int i = 0 ; i < tabHold.getTabWight().getChildCount ; i ++ ) {
				if(i == tabHold.getCurrentTab) {	//判断当前遍历到的项是否是正在选中的项
					tabHold.getTabWight().setBackgrondColor(Color.Gray);//选中，改变颜色
				}else {
					tabHold.getTabWight().setBackgroubdColor(Color.WHITE);//未选中，刷原颜色（即不变色）
				}
			}
		}

58.在setAdapter()中传入的item样式时（参考47点）可以使用系统自带的一些内容：
	android.R.layout.simple_list_item_checked //带选择框的ListView,用setChoiceMode()设置单选多选
		例：mlistView.setAdapter(new ArrayAdapter<String>(this,android.R.layout.simple_list_item_checked,数据源);
		    mlistView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
---------------------------------------------------------------------------------------------------------
	android.R.layout.simple_list_item_multiple_choice //带CheckBox的ListView,用setChoiceMode()设置单选多选
		例：mlistView.setAdapter(new ArrayAdapter<String>(this,android.R.layout.simple_list_item_multiple_choice,数据源);
		    mlistView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
----------------------------------------------------------------------------------------------------------
	android.R.layout.simple_list_item_single_choice	//带RadioButton的ListView,用setChoiceMode()设置单选多选
			例：mlistView.setAdapter(new ArrayAdapter<String>(this,android.R.layout.simple_list_item_single_choice,数据源);
		    mlistView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);

59.制作9.png图时，黑线表示要拉伸的区域

60.Android Studio 安装 IDEA Vim 插件：
	File――Setting――Plugn――搜Vim 

61.广播接收器基本用法：（在相应的onCreate()方法中进行操作，为动态注册，程序必须启动才能接受广播)
	1.创建IntentFilter实例，调用addAciton("ACTION..内容")方法添加action（想要接受怎样的广播就接收怎样的ACTION)
	2.通过内部类处理接收到广播的后的事件，内部类都要继承自BroadcastReceiver
		例如 class NetworkChangeReceiver extends BroadcastReceiver {}
		之后再在onCreate()方法中创建内部类实例
	3.在onCreate()方法中使用registeRecevier()注册 IntentFilter和 内部类实例
		例如：registerRecevier(netWorkChange,intentFilter);
	----之后记得要在onDestroyed()方法中取消注册：unregisterRecevier(intenFilter)	
	4.监听接受到广播要做出相应的响应重写内部类的onReceiver()
----------扩展功能
	5.可以在onReceiver()方法中获取系统服务类实例
		ConnetivityManger conetivityManger = (ConnetivityManger) getSystemService(CONNCTIVITY_SERVICE)//获取了一个专门管理网络连接的系统服务类
		之后可以通过创建该系统服务类的实例对象进行操作，例如此处我们要侦听网络连接的状态
		NetWorkInfo networkinfo = conetivityManger.getActiveNetWorkInfo();
		if (networkinfo != null && networkinfo.isAvailible){...}//检测网络是否可用
	6.当使用服务类进行侦听时，要去AndroidManifest.xml 声明权限
		例如上面侦听网络的权限：<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/><!--获取侦听网络状态的权限-->
-------------------------------------------------------------完整代码---------------------------------------------------------------------------------------------------------------------
public class MainActivity extends AppCompatActivity {
    private IntentFilter intentFilter;
    private NetworkChangeReceiver networkChangeReceiver;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        intentFilter = new IntentFilter();                              //创建IntentFiltershil实例
        networkChangeReceiver = new NetworkChangeReceiver();            //创建NetworkChangeReceiver实例
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); //添加Action，想接收什么样的广播就添加什么Action
        registerReceiver(networkChangeReceiver,intentFilter);           //注册两个实例
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(networkChangeReceiver);                      //当Activity运行结束后，解除实例的注册
    }

    class NetworkChangeReceiver extends BroadcastReceiver {             //写内部类，继承自BriadcastReceiver，重写onReceiver（）实现监听

        @Override
        public void onReceive(Context context, Intent intent) {
            ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);//获取系统服务类实例
            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();//在专门管理网络连接的系统服务类中获取实例
            if(networkInfo != null && networkInfo.isAvailable()) {//判断网络状态是否可用
                Toast.makeText(MainActivity.this,"网络可用",Toast.LENGTH_SHORT).show();
            }else {
                Toast.makeText(MainActivity.this,"网络不可用",Toast.LENGTH_SHORT).show();
            }
        }
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

62.静态注册广播接收器（61为动态）
	1.写一个外部类，继承自BroadReceiver，并重写onReceive()方法；
	2.在AndroidManifest.xml 声明权限、注册广播接受器
		（1）声明权限 <user-permission android:name = "所需权限"/>
		（2）注册广播接收器：
			<receiver android:name = ".接受器外部类名称"> //广播接收器的标签
				<intent-filter>
					<action android:name = "所要接收到广播ACTION名称"/>
				</intent-filter>
			</receiver>

63.广播接收器的onReceive()方法不能开启线程，所以不能写运行太长，逻辑太复杂的操作

64.发送自定义广播：
	通过在相应的触发事件的Intent对象进行发送（如在onClick事件触发时）：
		button.setOnClickListener(new View.OnClickListener() {
            	@Override
            		public void onClick(View v) {
                	Intent intent = new Intent("com.example.broadcasttest");	//自己定义的Action名，在写广播接受器时注意对应
                	sendBroadcast(intent);
            		}
		});
65.运行APP程序时覆盖原有APP：
	检查一下app\build.gradle文件里的applicationId是否与其他App存在冲，冲突则会覆盖
        	
66.发送有序广播的方法:
	（1）发送事件使用sendOrderedBroadcast(Itent对象，权限字符串可为null) 方法
	（2）在接收器注册的<intent-filter android:priority = "100" >设置优先级，数字越高优先级越高
	（3）如某个接收器要截断有序广播，在接收器的onReceive()中添加abortBroadcast()方法

67.使用内部广播：
	（1）与动态注册广播类似，但要通过LocalBrocastManager.getInten(this) 获取LocalBrocastManager实例 localBrocastManager
	（2）广播的 注册 localBrocastManager.registerReceiver()
		    取消注册 localBrocastManager.unregisterReceiver()
		    发送广播 localBrocastManager.sendBroadcast(intent)
		都通过 localBrocastManger进行
	（3）与同态注册相同，接受器写作内部类中

68.将数据存储到文件中：(默认输出路径在 data/data/包名/file/... 通过DDMS可以查看)
	（1）定义一个FileOutputStream参数，通过openFileOutput("保存的文件名",Context.MODE_PRIVATE|Context.MODE_APPEND)方式获取流对象，第二个参数两个值指覆盖已有文件|在已有文件中添加;
	（2）通过刚刚获取的流对象建立输出流对象，进行输出流操作;
--------------------例如--------------------------------------------------
		public void save (String inputText) {
			FileOutputStream out = null;
			BufferWriter writer = null;
			try {
				out = openFileOutput("data",Context.MODE_APPEND);	//获取流对象，存储在名为"data"的文件中，不覆盖原有文件
				writer = new BufferWriter(new OutStreamWriter(out); //将流对象定义为输出流
				writer.write(inputText);			//进行输出流操作
			}catch (IOException e) {
				e.printStackTrace();
			}finally {
				try {
					if ( write != null ) {
						write.close();	
					}	
				}catch(IOException e) {
					e.printStackTrace();
				}
			}
		}
----------------------------------------------------------------------------

69.从文件中读取数据：(默认读取路径：data/data/<包名>/file/文件名...)
	（1）定义一个FlieInputStream参数，通过openFileInput("文件名")方法获取流对象
	（2）通过获取的流对象建立输入流对象，进行读取操作;
******************************************例子：当要在onCreate()读取**********************************************************************
	onCreate()方法中：
		EditText edit = (Edit) findViewById (R.id.edit_text);//获取输入位置的对象，此处往一个EditText输入内容
		String inputtext = load(); //通过load()函数读入内容
		if(!TextUnit.isEmpty(inputtext)) {	//判断从load()读入的内容是否空，TextUnit.isEmpty()可同时判断空类型和空串
			edit.setText(inputtext);	//向控件输入内容
			edit.setSelection(inputtext.length()); //选择串尾
			...其他操作
		}
-----load()方法
	public String load() {
		FileInputStream in = null;
		BufferReader reader = null;
		StringBuilder content = new StringBuilder();//使用String缓冲对象输入数据
		try {
			in = openFileInput("data");//获取输入流对象，指定文件名为"data"		
			reader = new BufferReader(new InputStreamReader(in)); //使用输入流对象in构建流操作对象，进行输入流操作
			String line = "";		//临时读取存放参数
			while ( (line = reader.readLine()) != null ) {	//读一行文件判空
				content.apped(line);	//使用String缓冲对象在已有String末尾添加新串	
			}
		}catch(IOException e) {
			e.printStackTrace();
		}final {
			try {
				if( read != null) {
					reader.close();
				}
			}catch(IOException e) {
				e.printStackTrace();
			}
		}
	}
*****************************************************************************************************************************************

70.使用SharedPreference存储数据：（路径为：data/data/<包名>/shared_pre/文件名）
	1.通过SharePreference对象（三个获取方法直接.edit())获取SharePreference.Editor对象;
	2.使用SharePreference.Editor 对象添加数据(根据类型不同putString、putInt等)
	3.使用SharePreference.Editor 对象调用commit()方法提交添加到数据
		例子：
			SharePreference.Editor editor = getSharedPreferences("data",MODE_PRIVETE).edit();	//获取SharePreference.Editor 对象editor 文件名为"data",操作模式为本应用可操作
			editor.putString("name","Yamato");							//添加数据，是通过"键――值"对进行保存，所以第一参为String
			editor.commit();									//提交数据

71.使用SharedPreference读取数据：
	1.先获取SharePreference对象
	2.使用SharePreference对象 的(getString、getInt()方法获取数据）
		例子：
			SharePreference pref = getSharePreferences("data,MODE_PRIVETE);
			String s = pref.getString("name","");								//第一个参数是键名称，第二个参数采用默认值，String空，int 0
			

72.异步消息处理方法：
	1.定义整形常量，用于表示更新动作；
	2.新增一个Handler对象，重写handleMessage方法，对具体的Message进行处理，例如：
	private Handler handler = new Handler() {
		public void handleMessage(Message msg) {
			switch (msg.what) {
				case 常量 :
					....相应动作处理	
			}
		}
	};
	3.在监听触发事件中创建新线程：
		public void onClick (View view) {
			MyThread mythread = new MyThread();
			new Theread (mythread).start();
		}
	4.在run方法中发送Message:子线程要进行UI操作就要创建一个Message对象
		class MyThread implements Runnable {
			public void run() {
				Message message = new Message();
				message.what = 常量;
				handler.sendMessage(message);//发送Message对象，sendMessage()方法发出的方法最终会传递到handleMessage()方法中
			}
		}

73.使用AsyncTask进行多线程操作：
	创建子类继承AsyncTask:
		重写onPreRxecute()	//后台任务开始执行前调用
		    doInBackground()	//用于处理耗时任务
		    onProgressUpdate()	//接受上个方法中publishProgress()发出的参数，对UI进行操作
		    onPostExecute()	//后台任务处理完毕后调用，可进行关闭对话框等操作
	例：
	class DownloadTask extends AsyncTask<Void,Integer,Boolean> {
		protected void onPreExecute() { //开始前调用，显示对话框
			progressDialog.show();
		}
		
		protected Boolean doInBackground() {  //后台处理函数
			....后台进行的内容
			publishProgress(downloadPercent);//发对UI操作的参数
			return true;//返回boolean表示后台处理结束
		}

		protected void onPressUpdate() {     //更新UI
			
		}

		protected coid onPostExecute() {  //后台运行结束后收尾工作
				各种关闭操作
		}
	}
	
74.Servier使用方法：
	1.写一个外部类MyService，继承自Service.
		其中有一些需要重写的方法：
			(1) onBind()		//必须重写的方法
			(2) onCreate()		//Service创建时调用
			(3) onDestroy()		//Service 关闭时调用
			(4) onStartCommand()	//只要启动Service就会调用
	2.使用Intent对象打开或关闭Service:
		例：打开：Intent intent_start = new Intent(MainActivity.this,MyService.class);
			  startService(intent_start);
		    关闭：Intent intent_end = new Intent(MainActivity.this,MyService.class);
			  stopService(intent_end);
	3.在AndroidMainfist.xml中注册:
		<service android:name = ".MyService" />			//与<activity>同级

75.Servier与Activity的通信（即在Activity中调用服务的方法）:
	1.在新建的外部类中（MyService）新建一个继承自Binder的类，Activity中要调用的Service方法全部写在这个类中
	2.生成上面新类的实例，在onBinder()方法中返回该实例
	3.在要调用Servive的Activity中获取新类的实例(MyService.DownloadBinder downloadbinder)
	4.创建ServiceConnect的匿名类，用于和Service绑定：(会要重写两个方法，一个是onServiceConnected,一个是onServiceDisconnected)
		private ServiceConnection connetion = new ServiceConnection() {
			public void onServiceConnected(ComponentName name,IBinder service) {
				downloadBinder = (MyService.DownloadBinder) service;
				downloadBinder.startDownload();//绑定相应的方法
			}
		}
	5.在相应的触发事件中，使用Intent对象绑定或者解绑
		绑定：Intent bind = new Intent(MainActivity.this,MyService.class);
		      bindService(bind,connetion,BIND_AUTO_CREATE);//三个参数：Intent对象，匿名类绑定实例，标志位（当前标志位指绑定后自动创建服务）
		解绑:unbindService(connetion);

76.使用IntentService:(创建一个异步的、能自动停止的服务）：
	1.类似于使用Service，先创建一个继承自IntentService的类
		例如 ：public class MyIntentService extends IntentService {
				public MyIntentService(){	//添加一个构造方法
					super("MyIntentService");
				}
			
				onHandleIntent() {	//重写onHandleIntent()方法，要在子线程处理的内容放在这里
					...异步处理内容
				}
				...其他onDestroy(),onCreate()同Service了
			}
	2.与Service相同，使用Intent的startService()和stopService()方法开关服务
	3.也要对此服务进行注册

77.获取AlarmManager实例：
	AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
 
78.ViewPager使用方法：(类似于ListView):
	1.在相应的xml中添加 <ViewPager></ViewPager>控件
	2.写ViewPagerAdapter继承自PagerAdapter
		范例：
			public class ViewPagerAdapter extends PagerAdapter{
   	 			List<View> mviewlist = null;	//泛型为View个可以直接将布局文件放入List中

    				public ViewPagerAdapter(List<View> mviewlist) {
        			this.mviewlist = mviewlist;
    				}

    				@Override
    				public int getCount() {
        				return mviewlist.size();
    				}

   				@Override
    				public Object instantiateItem(ViewGroup container, int position) {
        				((ViewPager) container).addView(mviewlist.get(position));
        				return mviewlist.get(position);
    				}

    				@Override
    				public boolean isViewFromObject(View view, Object object) {
        				return view == object;
    				}

    				@Override
    				public void destroyItem(ViewGroup container, int position, Object object) {
        				((ViewPager) container).removeView(mviewlist.get(position));
					//super.destroyItem(container, position, object);
    				}

			}
	3.在onCreate中加载：
		范例：
			（1）View v1 = getLayoutInflater.Inflate(R.layout.layout1,null); //获取布局
			（2）ListView viewList = new ArrayList<View>();
				viewList.add(v1);	//将布局加入到数组中当作数据源，以上是准备数据阶段
			（3）ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager);	//获取viewPager对象
			     mpagerAdapter = new ViewPagerAdapter(viewList);//使用构造方法，构造Adapter
			     viewPager.setAdapter(mpagerAdapter);	//设置Adapter
			     viewPager.setCurrenItem(0);		//默认当前选中第一页
	

79.复用Adapter每次都要重新创建。

80.cd - 可以返回上次所在的目录

81.HttpURLConnection用法：
	1.获取HttpURLConnection对象
		(1)new Url 对象传入地址
		(2)Url对象调用openConnection()方法即可获取HttpURLConnection对象
	2.设置请求方法
		httpurlconncection.setRequestMethod("GET"/"POST");
	-----
	使用范例：
		HttpURLConnection httpurlconnection = null;	
		URL url = new URL("http://www.baidu.com");
                httpurlconnection = (HttpURLConnection) url.openConnection();//通过url对象获取HttpURLConnection对象
                //对HttpURLConnection对象进行基本设置
                httpurlconnection.setConnectTimeout(8000);//连接超时时间
                httpurlconnection.setReadTimeout(8000);//读取超时时间
                httpurlconnection.setRequestMethod("GET");//请求方法
                //获取流对象进行流操作
                InputStream in = httpurlconnection.getInputStream();

82.View对象旋转动画效果的使用方法：(在调用动画效果的.java中写)
	(1)设置RotateAnimation对象
		RotateAnimation animation = new RotateAnimation(起始旋转角度，最终旋转角度，View对象旋转中心点x坐标，View对象旋转中心点y坐标);
	(2)使用RotateAnimation进行一系列设置
		animation.setDuration(100);//设置动画持续时间
		animation.setFillAfter(true);//设置动画结束后是否保持当前状态，false则恢复会执行动画前的状态
	(3)View对象开启动画效果
		imageView.starAnimation(animation);
	(4)可以使用imageView.clearAnimation(); 方法清除存在的动画效果
	----------使用示例
		private void rotateArrow() { //设置图片的翻转动画效果
			float pivotX = arrow.getWidth() / 2f; //获取图片中心点的坐标
			float pivotY = arrow.getHeight() / 2f;

			float fromDegress = 0,toDegress = 0;//设置旋转动画的起始角度，和最终角度
			if (currentStatus == STATUS_PULL_TO_REFRESH) {//根据状态不同设置其实和结束角度
			    fromDegress = 180f;
			    toDegress = 360f;
			}else if (currentStatus == STATUS_RELEASE_TO_REFRESH) {
			    fromDegress = 0f;
			    toDegress = 180f;
			}
			RotateAnimation animation = new RotateAnimation(fromDegress,toDegress,pivotX,pivotY);
			animation.setDuration(100); //设置动画持续时间
			animation.setFillAfter(true);//设置动画结束后View对象是否保持当前状态
			arrow.startAnimation(animation);//View对象启用旋转动.画效果
		}
	
83.ListView的下拉刷新，自己写很麻烦，大概照着网上的走了一遍，所以只说使用方法，就是在ListView外嵌套<com.example.shao.news.RefreshableView></com.example.shao.news.RefreshableView>
将事先写好的RefreshableView.java和pull_to_refresh.xml引入

84.常见的输入流处理：
	private static String converStreamToString(InputStream is) {//定义函数，参数为输入流对象，使用时直接调用此函数
		BufferedReader read = new BufferedRead(new InputStreamReader(is));
		String line;
		try{
			StringBuilder builder = new StringBuilder();
			while((line = read.readLine()) != null) {
				builder.append(line);
			}
		}catch(IOException e) {
			e.printStackTrace();
		}finally {
			try {
				is.close();
			}catch(IOException e) {
				e.printStackTrace();
			}
		}
		return builder.toString;
	}

85.Android中添加获取HttpClient的方法：
	1.在build.gradle中添加 android{useLibrary 'org.apache.http.legacy'}

	2.选中相应的Moudle，右键属性(open moudle setting...)―――Dependencies选项卡――――加号――1――搜org.apache http client

86.上一点提出使用HttpClient编译时有使用过时API的提示，并给出警告：
	.有关详细信息，请使用-Xlint:deprecation重新编译。
	.有关详细信息，请使用-Xlint:unchecked重新编译。
   此时，请项目相对应的build.gradle中添加配置：（直接在文件后面加）
	allprojects {
    		gradle.projectsEvaluated {
        		tasks.withType(JavaCompile) {
            			options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
        		}
    		}
	}

88.HttpClient使用方法：
	1.通过DefaultHttpClient创建HttpClient实例
	2.创建HttpGet对象，传入url
	3.使用HttpClient对象调用excute获取存放响应内容的HttpResponse对象
	4.HttpResponse对象调用getEntity方法获取HttpEntity对象
	5.通过HttpEntity对象获取字符串
--------使用示例：
	HttpClient httpClient = new DefaultHttpClient(); //通过DefaultClient创建实例HttpClient
                HttpGet httpGet = new HttpGet("http://www.baidu.com");//创建HttpGet对象
                HttpResponse httpResponse = httpClient.execute(httpGet);//获取Response对象包含响应的返回信息
                if (httpResponse.getStatusLine().getStatusCode() == 200 ) { //判断是否得到响应
                    HttpEntity entity = httpResponse.getEntity();//通过entity获取字符串
                    String response = EntityUtils.toString(entity,"utf-8");

89.Android调试PC服务器时，地址不一定是127.0.0.1，得根据模拟器的不同查阅辨别

90.HttpClient使用PULL解析XML：
	1.先获取XmlPullParserFactory实例（使用XmlPullParsetFactory.newInstance()方法）
	2.通过XmlPullParserFactory实例的.newPullParser()方法得到XmlPullParser对象
	3.将返回的Response对象设置到XmlPullparser中（XmlPullparser对象使用setInput()方法）
	4.通过getEvenType获取一个int 进行解析（不等于xmlPullPaser.END_DOCUMENT）时将一直进行解析
-------例子：
	private void parseXMLwithPull(String xmlData) {
        try {
            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();//获取XmlPullParserFactory实例
            XmlPullParser pullparser = factory.newPullParser();//由XmlPullParserFactory实例获得XmlPullParser对象
            pullparser.setInput(new StringReader(xmlData));  //将返回的内容xmlData设置到XmlPullParser对象中去
            int evenType = pullparser.getEventType();       //获取参数类型进行解析

            //定义存放数据的参数
            String name = "";
            String id = "";
            String version = "";

            //开始进行解析
            while (evenType != XmlPullParser.END_DOCUMENT) { //说明解析没有结束
                String nodeName = pullparser.getName();//获取当前节点的名字
                switch (evenType) {
                    case XmlPullParser.START_TAG : //开始解析某个节点
                        if (nodeName.equals("id")) { //节点名等于id、version、name就使用nextText()方法获取内容
                            id = pullparser.nextText();
                        }
                        if (nodeName.equals("name")) {
                            name = pullparser.nextText();
                        }
                        if (nodeName.equals("version")) {
                            version = pullparser.nextText();
                        }
                        break;

                    case XmlPullParser.END_TAG : //结束解析某个节点
                        if(nodeName.equals("app")) {
                            Log.d("PULL",id);
                            Log.d("PULL",version);
                            Log.d("PULL",name);
                        }
                        break;
                    default:
                        break;
                }
                evenType = pullparser.next();//获取下一个解析事件
            }


        }catch (Exception e) {
            e.printStackTrace();
        }
    }

91.解析JSON时，发现报 at org.json.JSONTokener.syntaxError <450> 错误，检查服务器端的JSON格式是否正确

92.HttpClient + JSONObject 解析JSON：
	1.将存放响应内容的Response对象传入JSONArray，构建JSONArray对象;
	2.通过遍历JSONArray对象获取JSONObject对象
	3.通过JSONObject对象对JSON文件进行解析。
------范例：
	private void parseJOSNWithJSONObject(String jsonData) {
		try{
		    JSONArray jsonArray = new JSONArray(jsonData);//将Response对象传进来，构建JSONArray对象
		    for(int i = 0 ;i < jsonArray.length(); i++) { //遍历JSONArray对象，获取JSONObject对象
			JSONObject jsonObject = jsonArray.getJSONObject(i);
			String id = jsonObject.getString("id");// 使用JSONObject对象对JSON进行解析
			String version = jsonObject.getString("version");
			String name = jsonObject.getString("name");

			Log.d("JSON","id is:"+ id);
			Log.d("JSON","name is:"+ name);
			Log.d("JSON","version is:" + version);
		    }
		}catch (Exception e) {
		    e.printStackTrace();
        }
    
93.Android Studio 添加GSON:
	类似于85.搜索时搜GSON即可

94.使用GSON解析JSON：
	1.新建一个JavaBean用来存放JSON的内容；（因为GSON会自动将内容转化成对象）
	2.创建GSON对象；
	3.GSON对象调用.fromJson(Rrsponse对象,  new Type.Taken(){}.List<<创建的JavaBean>>{}.getType ) 方法将内容取出放到以创建的JavaBean为类的List中;(若不是JSON数组，第二参数为JavaBean.class)
	4.遍历取数
--------范例：
	private void parseJSONWithGSON(String response) {//使用GSON解析JSON
		Gson gson = new Gson();
		List<App> appList = gson.fromJson(response, new TypeToken<List<App>>(){}.getType()); //JSON数组通过TypeToken对象传入gson.fronJson方法中，通过Json方法，我们可以将JSON数据直接转成类App的对象
		for (App app:appList) {
		    Log.d("GSON","id is :" + app.getId());
		    Log.d("GSON","name is :" + app.getName());
		    Log.d("GSON","Version is :" + app.getVersion());
		}
    }

96.两种for循环的转换：
	for(int i = 0; i < appList.size();i++) {
		App app = appList.get(i);
		app.get(id);....其他操作
	}
----------
	for(App app:appList) {
		app.get(id);...其他操作
	}	allprojects {

97.Android Studio中使用.initialize()来替换废弃的.init()方法进行初始化
    	
98.
===============================================================NoHttp框架的使用===================================================================================================
*属于比较难的内容，不是很理解，主要参照DEMO写，列出主要步骤：
一、在build.gradle添加 compile 'yolanda.nohttp:nohttp:+' 引入最新的NoHttp包

二、新创建一个继承自Application的类用于对NoHttp进行初始化，主要内容包括：
	(1)定义一个静态的Appilcation 类型的变量，用来接收应用程序的Application；
	(2)重写 Application类的onCreate()方法，主要内容有:
		1.令Application类型变量 等于当前(this);
		2.初始化NoHttp;[使用 NoHttp.initialize(this);]
		3.打开调试模式；[使用 Logger.setDebug(true);] //注意Logger要选择NoHttp包里的
		4.打开日志；[使用 Logger.setTag(项目名称);] 
	(3)写Application 静态变量的get方法;
			----------------------------------------------范例-------------------------------------------
				public class MyApplication extends Application {
				    private static Application intance; //设置静态的Application 类型变量intance,用来接收应用程序的Application

				    public static Application getIntance() { //静态变量intance的get方法
					return intance;
				    }

				    @Override				//重写Application的onCreate()方法
				    public void onCreate() {
					super.onCreate();
					intance = this;//初始化intance
					NoHttp.initialize(this);//初始化NoHttp,键97点补充
					Logger.setDebug(true);//设置调试模式
					Logger.setTag("news");//打开日志
				    }
			-----------------------------------------------------------------------------------------------					
××××××××××××××××××××××××××××××记得要去Mainfest.xml中注册新创建的Application:
						<application
							android:name = ".MyApplication"
						></application>


三、在相应的MainActivity中使用:
	(1)全局定义一个请求特征码，在并发请求中可以用作区分;
	(2)全局定义一个请求队列RequestQueqe对象;
	(3)在Activity的onCreate()方法中生成请求队列:
		RequesetQueqe对象赋NoHttp.newRequestQueqe() 值
	(4)在需要访问Http的地方调用请求方法;
			----------------------------------------------范例-------------------------------------------
				
			-----------------------------------------------------------------------------------------------					

四、写前面调用的请求方法（主要的网络请求在这里实现）：
	(1)定义一个请求列表，根据请求数据类型的不同选择不同的泛型;
		Request<String|JSONArray> 请求列表名 = NoHttp.Create(String的URL地址,请求方法) //根据请求泛型的不同，参数也不同
	(2) 请求列表传入 提交到服务器的参数：
		请求列表.add("键","值");
	(3)将请求列表添加到请求队列中：
		请求队列的RequestQueqe对象.add(特征码，请求列表，请求监听器对象);

			----------------------------------------------范例-------------------------------------------
				
			-----------------------------------------------------------------------------------------------					

五、回调请求监听器对象，实现方法

			----------------------------------------------范例-------------------------------------------
				
			-----------------------------------------------------------------------------------------------					

==============================================================================================================================================================================
